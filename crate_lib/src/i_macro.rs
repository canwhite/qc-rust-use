/*
Rust 宏系统简介

Rust 的宏系统是一种强大的元编程工具，允许在编译时生成和操作代码。
与函数不同，宏可以在语法层面进行操作，提供更灵活的代码生成能力。

Rust 主要有两种宏：
1. 声明宏（macro_rules!）：使用类似模式匹配的方式定义宏
2. 过程宏：更强大的宏系统，分为三种类型：
   - 派生宏（#[derive]）
   - 属性宏（#[...]）
   - 函数式宏（macros!()）

宏的常见用途：
- 减少重复代码
- 创建领域特定语言（DSL）
- 实现编译时检查
- 自动生成代码

宏示例：

1. 声明宏示例：
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
}

2. 派生宏示例：
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

3. 属性宏示例：
#[route(GET, "/")]
fn index() {}

4. 函数式宏示例：
println!("Hello, {}!", "world");

使用宏的注意事项：
1. 宏可能使代码更难阅读和调试
2. 宏在编译时展开，错误信息可能不太直观
3. 过度使用宏可能导致代码难以维护

建议在确实需要时才使用宏，优先考虑使用函数和 trait 等 Rust 的其他特性。
*/
